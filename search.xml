<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>gitlab实践 --- 3. 使用 Gitlab 的技巧分享</title>
      <link href="/2020/06/tools/gitlab/skill.html"/>
      <url>/2020/06/tools/gitlab/skill.html</url>
      
        <content type="html"><![CDATA[<p>gitlab能介绍的内容实在是太多了，<a href="https://docs.gitlab.com/" target="_blank" rel="noopener">官方文档</a> 就已经涵盖了你想知道的所有内容。因此，打算把这一篇作为【gitlab实践】的一个<strong>结尾篇</strong>，但自己只是粗浅的品尝了gitlab的美妙，前两篇文章也都是一些很基础的知识分享，说是一个完整的系列都很牵强，不过毕竟第一次写这样的分享文章，至少要做到有始有终，不论好坏也要有始有终，毕竟我就是这么一个始终如一、从不拖延的好男人（不要在乎为什么隔了三个月才更新）。</p><p>大概说下这篇文章的一些重点吧，重点就是 — 没有重点，我想起什么就说点什么！</p><div align="center"><img src="https://www.python-dog.com/images/s/yc/pa.jpg" width="50%" height="50%"></div><h2 id="1-项目中可定义的模板"><a href="#1-项目中可定义的模板" class="headerlink" title="1. 项目中可定义的模板"></a>1. 项目中可定义的模板</h2><p>在使用gitlab中，一定会用到它自带的issue功能，虽然开源版本对issue的功能支持有限(毕竟白嫖),但对于小一些的团队来说已经足够用了。</p><p>issue也应该是有类型的，与issue类型关系最紧密的是label，每个issue都可以有任意多个label。每一个issue也对应到一类问题，例如它是一个bug、feature或者refactor。</p><p>因为issue应该有类型，所以就应该让同类型的issue书写格式都差不多，例如bug就应该有：</p><ul><li>相关报错信息</li><li>复现步骤</li></ul><p>而feature就应该有：</p><ul><li>目的（实现后的作用）</li><li>实现步骤</li><li>验收标准（一般是有默认标准，如所有测试都过了）</li></ul><p>针对更大的feature还需要RoadMap这样的规划，否则功能有可能不能按照预期时间实现</p><p>那么我们怎么能高效的创建不同类型的issue呢？答案就是创建模板</p><p>创建模板没有什么神奇操作，只要在你的项目下创建一个<code>.gitlab/</code>文件夹，并在其中创建一个<code>issue_templates</code>文件夹，将想要的模板形式以markdown的形式分文件存储就好了，如下：</p><pre><code># 项目A.gitlab/  - issue_templates/    - bug.md    - feature.mdother_files</code></pre><p>具体模板样式可以随便编写，或者参考已经存在的项目（如<a href="https://gitlab.com/gitlab-org/gitlab/-/tree/master/.gitlab" target="_blank" rel="noopener">gitlab项目</a>的模板）</p><p>还有哪些可以用模板的呢？<strong>MR也可以！</strong>。</p><hr><p>说到这里，还有个分享，我的理解gitlab的issue设计更加贴近敏捷开发，虽然<strong>敏捷开发</strong>已经被说烂了，但什么是真正的敏捷开发其实很多人并不清楚，并不是用上issue(或者其他分配issue的在线或离线工具)，再一味加班，一味强调功能快速合入就是敏捷开发了，那叫野蛮开发，没有规则的乱搞就是野蛮。</p><div align="center"><img src="https://www.python-dog.com/images/s/dog/angry.jpg" width="50%" height="50%"></div><p>在这里分享我看到的一篇比较好的敏捷开发介绍文章,<a href="https://cloud.tencent.com/developer/article/1004881" target="_blank" rel="noopener">你大概走了假敏捷：认真说说敏捷的实现和问题</a></p><h2 id="2-快进式（Fast-forward）合并与合并检查"><a href="#2-快进式（Fast-forward）合并与合并检查" class="headerlink" title="2. 快进式（Fast-forward）合并与合并检查"></a>2. 快进式（Fast-forward）合并与合并检查</h2><p>我个人是很推崇快进式合并的，好处就是能保证分支上的commit都很清新，麻烦的是每次合入前你都要保证你的分支与目标分支的base必须是一个。</p><ul><li><strong>分支示例1</strong>就是直接进行了快进式合并，完成后master指向D，合并并没有产生任何多余的commit。</li><li><strong>分支示例2</strong>是直接merge代码到master中的结果，master指向F， F是由B、D和A三次commit共同合并后产生的结果，F并不是有一个父提交，而是有多个。我对这种commit并没有很好的印象，它看着就很乱。</li><li><strong>分支示例3</strong>是使用rebase，让分支能快进式合并进master的示例，当你的分支与master基不相同时，使用rebase在本地做一次变基操作，让分支的基与master的基相同，再快进式。这样虽然D1可能与D有差距，但它更加的纯粹并且只有一个父提交。分支上看起来也更加的清晰。</li></ul><pre class="line-numbers language-doc"><code class="language-doc"># 分支示例1   master    |--> A        直接合并  A --> D    |     \--> D    my-branch# 分支示例2        master          |--> A --> B  直接merge A --> B --> F    |                 |        /     \--> D           \--> D --    my-branch# 分支示例3        master          |--> A --> B  先rebase A --> B  再合并 A -> B -> D1    |                       |     \--> D                  \-> D1    my-branch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在项目的通用设置中是可以将项目设置为快进式合并的，这样就必须遵从类似示例3那样进行一次合并了。</p><p>这些都是个人偏好，并不代表它是最好用（正确）的，只代表我个人喜欢这么做，rebase也好，直接merge也罢，都会面临合并冲突的问题，一旦有冲突，哪种方式都要花时间的解决。</p><hr><p>另外一个比较好的设置是<strong>合并检查</strong>中有一项，必须流水线通过才能合并，我认为任何项目都应该打开这个限制。</p><p>因为一个代码的合入本来就是有最低标准的，而这个最低标准并不应该由人来一直check，而应该交给机器，因为机器会完全按照最低标准来校验，不会有遗漏，而人很难保持这一点。</p><p>pipeline的知识之前也在<a href="https://www.python-dog.com/2020/03/tools/gitlab/runner.html">gitlab实践 — 2. Gitlab Runner 的使用心得</a> 中简单提到过。一个良好的pipeline过程其实就是一次完整的系统测试。当设置了<strong>必须流水线通过才能合并</strong>其实就是在最大限度的节省人力来保证代码的质量的。</p><h2 id="3-gitlab-邮箱的配置"><a href="#3-gitlab-邮箱的配置" class="headerlink" title="3. gitlab 邮箱的配置"></a>3. gitlab 邮箱的配置</h2><p>gitlab 是支持多种方式来提示的，其中最为基础的一个提示方式是使用邮箱。</p><p>邮箱这里其实也没有什么好介绍的，官方网站就有<a href="https://docs.gitlab.com/omnibus/settings/smtp.html" target="_blank" rel="noopener">完整文档教你怎么用第三方邮箱的SMTP来发送gitlab提示邮件</a></p><hr><p>写到这里其实还是有很多东西没有分享的，有的是觉得没有必要分享，没有技术含量。还有就是自己并没有深入了解的，不敢拿出来卖弄丢人。</p><p>想要了解一个未知事物，唯一的办法就是不断去探索它。</p><p>我对gitlab了解的还很有限，就先分享到这里，之后可能只会零散的更新关于gitlab的知识了，毕竟不是做运维的，对它的热情也仅限于自己业余鼓捣，工作上的需求都被运维同事搞定了，没有机会接触更多复杂问题。不过有好的东西还是会分享记录下来，学无止境，哪里会有什么<strong>完结篇</strong></p><div align="center"><img src="https://www.python-dog.com/images/s/study.jpg" width="50%"></div>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab实践 --- 2. Gitlab Runner 的使用心得</title>
      <link href="/2020/03/tools/gitlab/runner.html"/>
      <url>/2020/03/tools/gitlab/runner.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Gitlab Runner, Jenkins 见了会沉默，Travis 见了会流泪 — 鲁迅</p></blockquote><div align="center"><img src="https://www.python-dog.com/images/s/lx/whatever.jpg" width="50%" height="50%"></div><p><a href="https://www.python-dog.com/2020/03/tools/gitlab/build.html">gitlab 部署篇</a> 中的内容已经让我们能部署起一个熟悉自己的hub了，那到这里就结束了么？不！我们还需要研究更多gitlab的奥妙，这里就来分享下关于<code>gitlab runner</code>的知识！</p><h3 id="0-什么是Gitlab-Runner"><a href="#0-什么是Gitlab-Runner" class="headerlink" title="0. 什么是Gitlab Runner"></a>0. 什么是Gitlab Runner</h3><p>想必大家对<strong>CI/CD</strong>这个词并不陌生，它是<strong>持续集成/持续部署</strong>的英文简写，gitlab 中对持续集成的支持主要包括三个部分:</p><ol><li>gitlab code hub （gitlab项目主体） 用于托管代码</li><li>gitlab ci (也包含在gitlab主体中) 用于调度项目中定义的ci/cd工作</li><li>gitlab runner (单独的项目) 用于执行ci/cd中的具体job</li></ol><p>更便于理解的，如下图：</p><pre class="line-numbers language-doc"><code class="language-doc">|push code| |                          | - job1 ->  Runner-1  \                         |   ->  [Hub] -> [CI/CD] --> | - job2 ->  Runner-2  /                         | |                          | - job3 ->  Runner-3|push code|\__________________________/\___________________/            |                         |            V                         V          gitlab服务器              其他服务器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Runner 就是部署在其他的服务器上的一个服务。当有代码push到hub中，gitlab-ci会根据我们的<code>ci/cd</code>配置去执行相应的job，这些job实际的执行者就是gitlab-runner</p><h3 id="1-Gitlab-Runner的部署"><a href="#1-Gitlab-Runner的部署" class="headerlink" title="1. Gitlab Runner的部署"></a>1. Gitlab Runner的部署</h3><p>对gitlab runner 的安装，其实没什么好分享的，它的<a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">官方文档</a>中各个版本的<a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener">安装</a>都讲解的很详细，我主要介绍一些个人的理解。</p><p>gitlab runner 的注册需要两个信息，CoordinatorURL和Token，这两个都是注册所需的关键，可以在gitlab全局配置(Admin Area下Runner项，以下简称为<strong>Runner管理页</strong>)中看到，如下图：</p><div align="center"><img src="https://www.python-dog.com/images/cut/gitlab/runner_manager.png" width="80%"></div<h4 id="0-用docker安装gitlab-runner"><a href="#0-用docker安装gitlab-runner" class="headerlink" title="0. 用docker安装gitlab runner"></a>0. 用docker安装gitlab runner</h4><p>可以在docker hub官网下载你喜欢的<a href="https://hub.docker.com/r/gitlab/gitlab-runner/tags" target="_blank" rel="noopener">gitlab runner image</a>版本，最好下载最新版本的，即<code>docker pull gitlab/gitlab-runner:latest</code>所下载的版本。</p><p>docker的好处就不用多说了,用Gitlab Runner的好处也有很多，最大的好处我也在之前介绍gitlab安装中提到了，无需担心且不会遇到任何由于环境不同而出现的安装问题，所以，再次建议大家用docker吧</p><pre class="line-numbers language-shell"><code class="language-shell"># docker 注册 gitlab runnerdocker run -v /self-path:/etc/gitlab-runner -v /var/run/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:latest register<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>命令解释：</p><ul><li><code>/self-path:/etc/gitlab-runner</code>: 将runner 配置映射到本地目录，这个很重要！</li><li><code>/var/run/docker.sock:/var/run/docker.sock</code>: 将本地的docker.sock与外部链接，这个是让docker runner启动docker类型的job的关键，后面会对它有更多的解释。</li><li><code>register</code>: 注册，运行gitlab注册的工作。</li></ul><p>运行完上述命令会依次出现以下提示（由于runner版本不一样，提示的内容可能有区别，不过都是大同小异的）</p><pre class="line-numbers language-shell"><code class="language-shell">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):# 提示输入Coordinator,正常输入即可Please enter the gitlab-ci token for this runner:# 提示输入Token, 正常输入即可Please enter the gitlab-ci description for this runner:# 提示输入该runner的描述，这个可以随意输入Please enter the gitlab-ci tags for this runner (comma separated):# 提示输入该runner的tag，tag是gitlab-CI/CD调度job在runner上运行的标识，可以先随意设置，该值可以在AdminArea-Runner下修改Please enter the executor: custom, docker-ssh, parallels, shell, ssh, docker, virtualbox, docker+machine, docker-ssh+machine, kubernetes:# 提示选择runner的执行者类型，我这里只选择过docker,shell和docker+machine,shell是首选，它能满足我们的大部分需求，若选择了docker，我们需要选择默认的imagePlease enter the default Docker image(e.g. ruby:2.6):# 提示输入默认的docker image, 只有当执行者选择为docker时会提示。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入完上述指令后，可检测下<strong>Runner管理页</strong>，应该已经出现了我们注册的runner，但细心的可能发现了，Runner 在线数还是显示为0，这是因为我们只注册了，并没有启动！启动命令就更加简单粗暴了！</p><pre class="line-numbers language-shell"><code class="language-shell"># 启动gitlab runnerdocker run -d --restart=always --name gitlab-runner-1 -v /self-path:/etc/gitlab-runner -v /var/run/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>self-path</code>和注册中的path是一个，这个很好理解，注册将信息都报保存在了配置文件<code>config.toml</code>中了。查看我们指定的<code>self-path</code>可以看到确实有一个config.toml文件，内容类似如下:</p><pre class="line-numbers language-doc"><code class="language-doc">concurrent = 1check_interval = 0[session_server]  session_timeout = 1800[[runners]]  name = "xxxx"  url = "xxx"  token = "xxxx"  executor = "docker"  [runners.custom_build_dir]  [runners.docker]    tls_verify = false    image = "alpine:latest"    privileged = false    disable_entrypoint_overwrite = false    oom_kill_disable = false    disable_cache = false    volumes = ["/var/run/docker.sock:/var/run/docker.sock", "/cache"]    shm_size = 0  [runners.cache]    [runners.cache.s3]    [runners.cache.gcs]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在我们启动之后，再次查看<strong>Runner管理页</strong>，这时候在线数应该已经是1了。</p><p><strong>Runner管理页</strong>中可以配置各个runnerg归属的项目或tag等信息，很是方便，若想某个项目独享某个Runner，就需要我们设置这些了。runner分为三种：Shared, specific and group Runners， 具体可以参考<a href="https://docs.gitlab.com/ee/ci/runners/" target="_blank" rel="noopener">这里</a></p><h4 id="1-在Ubuntu上部署Gitlab-Runner"><a href="#1-在Ubuntu上部署Gitlab-Runner" class="headerlink" title="1. 在Ubuntu上部署Gitlab Runner"></a>1. 在Ubuntu上部署Gitlab Runner</h4><p>这部分并没有什么好说的，和安装其他Ubuntu软件没有区别，按照<a href="https://docs.gitlab.com/runner/install/linux-manually.html" target="_blank" rel="noopener">官方文档</a>的介绍就能完成安装。</p><p>安装后我们可以通过<code>sudo gitlab-runner -h</code> 来查看可执行的所有命令</p><ul><li><p><strong>注册</strong>的步骤和docker中的基本一致，在此我就不多赘述了。</p></li><li><p>在<strong>启动</strong>时候和docker中略有不同，因为docker中将所有命令都封装好了，所以我们直接运行就能启动一个Runner，但机器上启动的Runner需要我们自己去输入命令。</p></li></ul><p>这里只大概说一下，大家可以去自己摸索其中的奥妙，整个过程分为三步<code>register -&gt; install -&gt; start</code>，register不多说了，<strong>install</strong>可以想象成我们安装一个runner到本地gitlab runner管理中心，start 就是启动一个已经install的runner。</p><p>这三个步骤都有对应的disable命令<code>unregister, uninstall, stop</code>，可以很方便的完成本地runner的管理。</p><p>这里再多提一句，Runner在install时最好指定一个user，这个user可以是我们新建一个用户（如tester）,否则可能会导致我们运行job时当前用户被runner占用的问题。我们可以这么理解下，每一个runner都是实际的linux用户，当runner指定的user和我们当前用户为一个时，若有job需要runner做时，必定会导致该用户被占用住。所以<strong>若没有特殊要求，最好分配一个独立的user给runner使用</strong></p><p>更多的配置可以查看<a href="https://docs.gitlab.com/runner/configuration/" target="_blank" rel="noopener">gitlab runner配置官方文档</a>，在此不多赘述了。</p><hr><p>到这里部署一个实际的Runner就介绍完了，终于介绍完枯燥却必须的部分了！下面就开始runner的使用！</p><div align="center"><img src="https://www.python-dog.com/images/s/yc/yes.jpg" width="20%"></div><h3 id="2-Gitlab-Runner的使用"><a href="#2-Gitlab-Runner的使用" class="headerlink" title="2. Gitlab Runner的使用"></a>2. Gitlab Runner的使用</h3><h4 id="0-gitlab-ci-yml的介绍与使用"><a href="#0-gitlab-ci-yml的介绍与使用" class="headerlink" title="0. gitlab-ci.yml的介绍与使用"></a>0. gitlab-ci.yml的介绍与使用</h4><p>在上面介绍的<em>什么是Gitlab Runner</em>中描述到当<strong>push code</strong>后会触发CI/CD，而这个触发规则，以及如何调度runner去执行哪个job等工作都是靠<strong>.gitlab-ci.yml</strong>做的，它是一个实际的文件，配置在我们项目的根目录（这个配置是可以在gitlab中修改的，理论上可以改到项目的任意目录下）。</p><p>Runner执行具体的job，job根据<code>.gitlab-ci.yml</code>定义，<code>.gitlab-ci.yml</code>存在于code项目根目录下。</p><p>假设我们的项目目录为：</p><pre class="line-numbers language-doc"><code class="language-doc">- README.md- test.1- .gitlab-ci.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中<code>.gitlab-ci.yml</code>中内容如下：</p><pre class="line-numbers language-yml"><code class="language-yml"># 定义 stagesstages:  - build  - build2# 定义 jobjob1:  stage: build  image: python:3.7.1  tags:    - runner-tag1  script:    - echo "I am job2"    - echo "I am in build stage"job2:  stage: build2  only:    refs:      - merge_requests  tags:    - runner-tag2  script:    - echo "I am job1"    - sleep 10    - git status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>stages： 为整个ci的入口，每个<code>push code</code>的请求都会顺序经过所有的步骤，并选择适合自己的步骤来执行</li></ul><hr><ul><li>job1: 定义的步骤具体内容，<code>job1</code>只是一个名字，可以随意命名。</li><li>job1-stage: 步骤tag， 该值对应到 <code>stages</code></li><li>job1-tags: runner tag，该值就是我们启动的runner所对应的那个tag名，可以选择多个runner来执行同一种job</li><li>job1-script: job中执行的具体命令，shell脚本命令</li><li>job1-image: 指定job使用的image，若使用该选项，那么runner 必须是一个docker执行者</li></ul><hr><ul><li>job2-only: 指定该job在那种情况下触发，上面描述的是当来自一个MR的请求时候才去触发该job。</li></ul><p>在我们按照个人喜好去编写了专属项目的<code>.gitlab-ci.yml</code>文件后，我们推送项目到hub中，可以看到流水线上运行起来了我们的job，点击进入job中我们可以看到，在最开始并不是执行我们的<code>scripts</code>，而是做了很多的其他工作，初始化了我们的当前项目代码库到job执行目录下，之后才执行的我们shell脚本命令。</p><p>所以，任何能在本地运行的编译，测试，部署与发布工作，理论上都能靠gitlab runner做，无非是多种runner和多种job的组合而已。</p><p><code>.gitlab-ci.yml</code>的配置有太多了！我相信能满足你的任何要求，可以查看<a href="https://docs.gitlab.com/ee/ci/yaml/README.html" target="_blank" rel="noopener">官方文档-gitlab-ci配置</a>，好好探索！</p><p>面对这么全的官方文档，我真的不知道该分享什么了，它真的太全了！全的我都没坑可以填！</p><div align="center"><img src="https://www.python-dog.com/images/s/dog/confused.jpg" width="50%"></div><h3 id="3-‘docker-in-docker’-在-Runner-中的使用"><a href="#3-‘docker-in-docker’-在-Runner-中的使用" class="headerlink" title="3. ‘docker in docker’ 在 Runner 中的使用"></a>3. ‘docker in docker’ 在 Runner 中的使用</h3><p>你们以为我真的没有什么想要分（水）享（字）的内容了么？你们想对了！</p><div align="center"><img src="https://www.python-dog.com/images/s/dog/angry.jpg" width="20%"></div><p>思考半天还是觉得有必要提一下dind在Runner中的使用。</p><p>在我们使用docker时第一步就是build image，而build其实只是一个简单的命令<code>docker build</code>，但这在Runner中有两个问题：</p><ol><li>Runner中没有docker，docker相关命令如何运行？</li><li>image build完成后如何让别的Runner能使用？</li></ol><p>我先说下第2个问题，我暂时还没试验过，不过可以通过各种docker hub（自己搭建或者云服务）来解决，像hub的隐私性等问题（主要是login时的账号密码），可以用环境变量的方式保证部分安全性。</p><p>问题1就涉及到了要介绍的dind，为了job能运行docker，我们需要做一下修改：</p><ol><li>将job的image设置为 <code>docker:dind</code>，这是dind的image</li><li>将job对应的docker Runner的配置<code>privileged</code>修改为true</li><li>重启对应的Runner</li></ol><p>这样，我们的runner 就能用docker了，用的docker就是我们物理机上的那个docker，所以千万不要执行一些危险命令，如删除等操作，最好只作为build image 来用。</p><p>说道这里我其实还是很气，因为这个方法官方也在<a href="https://docs.gitlab.com/runner/executors/docker.html#use-docker-in-docker-with-privileged-mode" target="_blank" rel="noopener">文档</a>中清楚的标出来了，还用一个专门的<br>标签给列出来了！我是找了半个小时才从其他网站找到的这个方法！</p><div align="center"><img src="https://www.python-dog.com/images/s/doubt.jpg" width="30%"></div><hr><p>最后，希望大家能通过gitlab runner提高自己的效率，让烦人的ci/cd工作能进行的越来越顺利！</p><p>之后还会分享下，在使用gitlab时的一些心得，这个系列就暂时告一段落了，但不断学习的的心永不停止。</p><div align="center"><img src="https://www.python-dog.com/images/s/study.jpg" width="50%"></div>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitlab实践 --- 1.用docker部署gitlab</title>
      <link href="/2020/03/tools/gitlab/build.html"/>
      <url>/2020/03/tools/gitlab/build.html</url>
      
        <content type="html"><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>在大学时就对gitlab有些简单的了解，不过那时候还是个青葱少年，觉得这种庞大的工具并不适合个人去“折腾”（PS:主要是懒，觉得github直接托管自己的烂代码就行了）,正式使用gitlab是在去年2月份了，开始使用除了代码管理相关的功能还大概知道是个啥，剩下的都是</p><div align="center"><img src="https://www.python-dog.com/images/s/what.jpg" width="20%" height="20%"></div><p>通过慢慢的摸索，知道了个大概，不过只能算作盲人摸象，只了解了自己知道的部分，于是有了自己搭建慢慢探索的想法，其中问题还是有很多的，于是决定分享出来从搭建到使用的个人经验。</p><h3 id="1-准备部署"><a href="#1-准备部署" class="headerlink" title="1. 准备部署"></a>1. 准备部署</h3><p>gitlab 对硬件是有一定要求的，有兴趣的可以去看下<a href="https://docs.gitlab.com/ee/install/requirements.html" target="_blank" rel="noopener">官方文档</a>中具体的描述，另外多提一句，我的所有经验也都是看官方文档来的，它的文档十分健全。</p><h4 id="下面列出了我搭建gitlab的服务器配置"><a href="#下面列出了我搭建gitlab的服务器配置" class="headerlink" title="下面列出了我搭建gitlab的服务器配置"></a>下面列出了我搭建gitlab的服务器配置</h4><ul><li>操作系统：<a href="https://wiki.ubuntu.com/BionicBeaver/ReleaseNotes" target="_blank" rel="noopener">ubuntu 18.04 个人桌面版</a></li><li>CPU： 4核/1.6GHz</li><li>内存： 8GB</li><li>硬盘： 200G SSD</li></ul><p>我用陪伴我走完大学四年的<a href="http://detail.zol.com.cn/series/16/16737_1.html" target="_blank" rel="noopener">戴尔灵越 14（3437)笔记本</a>装上ubuntu18，秒变服务器。这个系列笔记本已经停产了，就像我的青春一样永远定格在了那年。我推荐大家若手头有废弃的笔记本也可以像我这样当服务器用，而且<a href="http://detail.zol.com.cn/series/16/16737_1.html" target="_blank" rel="noopener">根据官方文档的安装建议</a>，若运行在使用内存不足4GB的系统上会有可能发生未知的500错误，腾讯/阿里云太贵了！！！，4GB没个千八的一年是下不来的，当然土豪就当我没说（说到这里留下了贫穷的泪水）</p><p>最后，在这个机器上安装个docker，为什么非要用docker，之后会慢慢说明。可以根据<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">官方文档</a>来一步一步安装。</p><h3 id="2-开始部署"><a href="#2-开始部署" class="headerlink" title="2. 开始部署"></a>2. 开始部署</h3><h4 id="用docker部署gitlab"><a href="#用docker部署gitlab" class="headerlink" title="用docker部署gitlab"></a>用docker部署gitlab</h4><p>熟悉docker的都知道，部署docker服务只要有相关服务的image就行了，这也是我推荐用docker来部署这种复杂应用的原因，在我还没部署自己的gitlab时，搜索过部署相关的一些文章，我看到很多的问题都出在了环境配置等细节问题上的，我们想用gitlab，想研究它的使用等问题，不应该去关心那些细枝末节的问题。</p><p>上面忘了说一点，我这里gitlab相关的文章都是基于CE版本的，也就是免费版，gitlab提供EE版，EE版的功能更加的强大，强大到所有的软件开发相关的所有流程用它就够了，不过太贵了！！！（又一次留下贫穷的泪水）</p><p>在<a href="https://hub.docker.com/r/gitlab/gitlab-ce/" target="_blank" rel="noopener">gitlab-dockerhub</a>中选择一个你喜欢的版本pull下来（推荐gitlab/gitlab-ce:latest 我一直觉得最新的应该是最好的，要不为啥费劲升级），这个过程可能比较慢，它的image比较大。</p><p>有了image之后就是运行简单的docker命令来将gitlab部署起来，命令如下：</p><pre class="line-numbers language-bash"><code class="language-bash">docker run -d --restart<span class="token operator">=</span>always --name gitlab-ce \-p 8080:80 -p 8022:22 -p 8443:443 \-v /self-path:/etc/gitlab -v /self-path:/var/log/gitlab -v /self-path:/var/opt/gitlab \--hostname 127.0.0.1gitlab-ce:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的命令说明：</p><ul><li>restart=always 能保证在重启系统后docker能自动将gitlab-ce这个服务也一起启动了，也能在服务出错时主动尝试重启</li><li>p xxxx:yyyy 是本地端口映射到容器内部，gitlab最需要的其实就两个80和22，443是当你设置了https时才有用的，可以不设置。</li><li>v xxxx:yyyy 本地路径与容器内部路径的映射，这一项的三个都要配置，上面命令中写的<code>/self-path</code>是指任意的你想要存储gitlab数据的路径，推荐放到当前用户下就行了，<a href="gitlab/gitlab-ce:latest">gitlab文档</a>中对这几个目录存储内容进行了说明，不过看目录结构应该也能猜出个七七八八了</li><li>hostname 这个需要配置，可以是ip或域名，若只自己在本地做研究，这个参数就配置为127.0.0.1</li></ul><p>执行完上面的命令之后就是等待，第一次总是漫长且痛苦。在等待的时候可以打开浏览器，访问 <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a>，直到出现如下图</p><!-- gitlab create 图片 --><div align="center"><img src="https://www.python-dog.com/images/cut/gitlab/first_set.jpg" width="80%" height="80%"></div><p>第一次运行成功后需要我们提供一个管理员密码，输入了合适的密码后会跳转到登陆页，用户名是root，密码是你刚才设置的，正确登陆后就能正式开始使用只属于你的gitlab了。</p><div align="center"><img src="https://www.python-dog.com/images/cut/gitlab/login.jpg" width="80%" height="80%"></div><div align="center"><img src="https://www.python-dog.com/images/cut/gitlab/index.jpg" width="80%" height="80%"></div><h3 id="3-使用中的问题"><a href="#3-使用中的问题" class="headerlink" title="3. 使用中的问题"></a>3. 使用中的问题</h3><p>现在，我们拥有了一个属于自己的gitlab，是不是打算撸起袖子咔咔咔的写下第一个自己的项目？</p><p>当你创建了第一个项目，开始pull项目，你发现由于你弄的是私人项目在用http方式pull项目时需要你输入账号密码，你开心的输入了上面的管理员账号密码，心满意足的pull下了项目，是不是感觉，哇，好棒！你转念想，“我不能每次push/pull都输入密码吧，那我还怎么独享这美妙的Coding Moment”，于是你将本地的ssh公钥添加到了项目ssh-key管理中。</p><p>“OK，可以开始美妙的Coding啦！” 你想着，并git pull了项目对应的ssh地址，奇怪的事情就发生了，你并不能pull下来。回想部署时，ssh端口并不是绑定的22，因为机器的22端口是被占据的。在痛斥为啥只能有一个22端口，大骂辣鸡gitlab为啥不解决这个问题后，你一定陷入沉思，可能会从史前文明想到晚饭是吃西红柿鸡蛋还是吃红烧牛肉，等你缓过神来，决定要给这个问题解决了！</p><p>于是你打开浏览器，简单的搜索后发现这个也太简单了！直接修改ssh配置就好了，编辑用户目录下<code>.ssh/config</code>：</p><pre class="line-numbers language-doc"><code class="language-doc">Host 127.0.0.1    Port 8022<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次pull/push 就完全没有问题了！</p><p>你们会觉得上面说的那个“你”其实是我？怎么可能？我晚饭只会选老坛酸菜！</p><p>到了这里基本的部署就完成了，若只是在本地自己玩那么可以关闭文章开始你的gitlab旅程了。若你真的想把它当一个服务用在自己的生活中，那么你就可能需要它能在公网中访问了。</p><h3 id="4-公网访问自建的gitlab"><a href="#4-公网访问自建的gitlab" class="headerlink" title="4. 公网访问自建的gitlab"></a>4. 公网访问自建的gitlab</h3><p>公网访问这里，基本就和gitlab没有什么关系了，只要你部署在自己电脑上的服务想要通过公网能访问，这个方法都是适用的。</p><p>由于我们个人是没有固定IP的，所以导致本地的服务不能通过固定IP暴露到公网上，针对这个问题最简单的方式就是找一个有固定IP的机器，然后将相应的访问转发到本地个人机器上就行了。</p><p>这里我推荐的工具是 <a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">【frp】</a></p><p>那么固定的IP机器哪里能获得呢？还得去云服务商那里去买，你们会疑惑，“难道你说的土豪就是自己？”，No No No，我还是那个穷B，只是云服务商定期会打折出售低端的服务器（一般都是1核2G/1G的）一二百多块一年还是比较实惠的，用来转发流了这配置应该是够了。</p><p><a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">frp</a>十分强大，且有良好的文档，有兴趣的可以好好读一下，我不在赘述其他的，只讲我们如何做能让我们gitlab公网访问到。直接下载、打开它的<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">release package</a>会看到下面有fprc和fprs两个命令，对应它的客户端和服务端程序，以下没有列出它的启动命令只列出配置信息，启动命令可以去文档中看一下。</p><h4 id="1-本地启动frp客户端"><a href="#1-本地启动frp客户端" class="headerlink" title="1. 本地启动frp客户端"></a>1. 本地启动frp客户端</h4><p>由于我们需要将云服务机器的流量转发到个人机器上，所以需要在本地启动客户端。直接修改frp下的客户端配置文件<code>frpc.ini</code>内容为</p><pre class="line-numbers language-doc"><code class="language-doc">[common]server_addr = [云服务器的IP]server_port = [云服务器暴露的端口][gitlab-web]type = httplocal_port = [docker启动gitlab时设置的80对应端口，文章中的是8080][gitlab-ssh]type = tcplocal_ip = 127.0.0.1local_port = [docker启动gitlab时设置的22对应端口，文章中的是8022]remote_port = [服务端设置的ssh转发端口]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里要说明的一点是，这里要更改一下上面部署中的<code>hostname</code>，改为server_addr 对应的值。</p><h4 id="2-服务器启动frp服务端"><a href="#2-服务器启动frp服务端" class="headerlink" title="2. 服务器启动frp服务端"></a>2. 服务器启动frp服务端</h4><p>在云服务器上启动frp的服务端，修改<code>frps.ini</code>为</p><pre class="line-numbers language-doc"><code class="language-doc">[common]bind_port = [服务器暴露的端口，用于与客户端连接，该值和frpc.ini中的server_port应该相同][ssh]listen_port = [服务器接收ssh请求的端口，用于将ssh请求转发到客户端，该值和frpc.ini中的remote_port应该是相同的]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一点要说明，<code>【3. 使用中的问题】</code> 中提到的本地ssh配置问题，Host 设置为服务器IP，Port 设置为 <code>listen_port</code></p><p>到这里就可以在公网访问你的gitlab了！</p>]]></content>
      
      
      <categories>
          
          <category> tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新blog事件记录</title>
      <link href="/2019/11/other/update.html"/>
      <url>/2019/11/other/update.html</url>
      
        <content type="html"><![CDATA[<p>最开始尝试过自行搭建blog，<a href="https://github.com/shihbas/blog-yuehu" target="_blank" rel="noopener">django作为后端</a>用<a href="https://github.com/shihbas/blog-butterfly" target="_blank" rel="noopener">vue构建前端</a>, 但是最终的兴趣都被各种奇怪的vue或部署等问题磨没了，于是毅然放弃了自己维护的方案</p><hr><p>20200220， 正式采用<a href="http://gitlab.python-dog.com/" target="_blank" rel="noopener">自己的gitlab</a>托管blog原代码，生成的页面部署在github page上， 博客采用<a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">hexo</a>，对使用的主题<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">matery</a>也做了一些更适合自己的修改，之后会慢慢进行修改，达到自己最喜欢的状态。</p><p>预计要写的主要还应该是以python为主，其他的为辅。现在最想要写的是gitlab的一些知识，从搭建到部署，分享自己这段时间的研究。python方面，暂时想的是深入（根据源码或文档）分析一个框架（django或者flask）,不过最近更想研究python的并发处理。</p><hr><h2 id="2020-04-06-17-24-14"><a href="#2020-04-06-17-24-14" class="headerlink" title="2020-04-06 17:24:14"></a>2020-04-06 17:24:14</h2><p>迟到的更新</p><p>恰逢清明，将网站全体改为暗色。哀悼烈士，也追思亲人，时间至少持续到 <strong>2020-04-12</strong></p><p>愿逝者安息，尚飨。</p><hr><h2 id="2020-06-22-01-10-31"><a href="#2020-06-22-01-10-31" class="headerlink" title="2020-06-22 01:10:31"></a>2020-06-22 01:10:31</h2><p>这个是更新最近的个人问题和计划的，与blog变化基本无关。</p><p>但是最近工作比较忙，疫情导致长期在家办公，让工作、学习、娱乐与休息的界限变得越来越模糊，最开始的学习计划也一塌糊涂了。</p><p>现在的状态并不好，每周没有固定的时间去充实自己，也没有休息或娱乐好，应该尽快调整状态适应这种疫情办公的节奏。</p><h3 id="关于休息"><a href="#关于休息" class="headerlink" title="关于休息"></a>关于休息</h3><p>最近不知道是怎么回事，一直失眠，可能是长期在家办公缺少运动量导致的吧，也有可能是受疫情影响，在家憋的时间太长了心情压抑导致晚上睡不着。不过也不知道怎么解决。</p><blockquote><p>鲁迅也说过：没有不失眠的少年，能呼呼大睡的那都是猪精</p></blockquote><div align="center"><img src="https://www.python-dog.com/images/s/lx/whatever.jpg" width="50%"></div><p>所以我也不用太在意每天睡不着这件事，我只要解决我每天起不来这件事就好了。毕竟像我这种150斤的少年每天晚上胡乱思考睡不着觉很正常。</p><p>现在能想到的是每天提前一点上床准备睡觉，早晨多定几个闹钟，其他的好方法还没找打也懒得再试了。</p><h3 id="关于学习计划"><a href="#关于学习计划" class="headerlink" title="关于学习计划"></a>关于学习计划</h3><p>这周开始每周<del>必须</del>选择性更新至少 <del>三篇</del> <del>两篇</del> 一篇关于python的技术文章，毕竟我是一个python狗，必须得不断提高python知识。当前想到的方向有两个：</p><ul><li>并行编程： 这部分现在做的还不是很熟悉，只是会写很基础的代码，并没有掌握它的奥妙，可以以之前一直想尝试的<strong>自己写pylint</strong>项目来熟悉这部分。</li><li>python unittest的编写： 这部分还算是有些心得体会，可以出一个系列，将<ul><li>python中如何编写更好的unittest</li><li>如何对各种外部环境做mock, mock的神奇功效</li></ul></li></ul><p>而非Python部分</p><ul><li>vscode插件已经TS语法</li><li>尝试研究，实现IM系统</li><li>丰富自己的树莓派功能并分享</li><li>linux 知识或shell的记录与分享</li><li>一致性算法的研究</li><li>常用工具如： redis， mysql, elasticsearch等等的深入了解</li></ul><p>现在不打算研究的部分</p><ul><li>Go 的进阶</li><li>flutter的入门</li><li>K8S</li></ul><p>希望之后的三个月能逐步按照计划进行，到时候会奖励自己出去玩一圈。</p><hr><p>以上的学习计划也会是本blog近期更新知识的方向。</p><div align="center"><img src="https://www.python-dog.com/images/s/study.jpg" width="50%"></div><hr>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> update </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
